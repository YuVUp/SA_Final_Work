# 12	Постановки на разработку
Первый релиз системы ориентирован на реализацию минимально жизнеспособного продукта (MVP), покрывающего ключевые сценарии взаимодействия посетителя с роботизированным рестораном. Данный раздел содержит детализированные технические задания на реализацию компонентов системы.

## 12.1.	Постановки на разработку функционала, реализуемого в рамках первого релиза

### **US-01: Просмотр категорий меню**
*   **Как:** Посетитель
*   **Я хочу:** видеть главные категории блюд (бургеры, закуски, напитки, десерт) на начальном экране
*   **Чтобы:** быстро сориентироваться и выбрать нужный раздел меню.

**Задача 1.1: Реализовать API эндпоинт для получения списка категорий меню**
**Цель:** Создать backend-метод, который возвращает категории для фильтрации меню на главном экране.

**Функции:**
*   **Метод GET /categories**
*   Аутентификация не требуется.
*   Возвращает список категорий (например, "Все", "Горячее", "Напитки", "Десерт").

**Задача 1.2: Реализовать главный экран приложения с категориями**
**Цель:** Воспроизвести экран "Главное меню" с панелью категорий.

**Элементы по макету:**
*   Панель категорий: Кнопки, полученные из API `/categories`.
*   Визуальное выделение активной категории.
*   Список товаров, фильтруемый по выбранной категории.

### **US-02: Просмотр деталей блюда**
*   **Как:** Посетитель
*   **Я хочу:** видеть для каждого блюда название, изображение, описание и цену
*   **Чтобы:** принять осознанное решение о выборе.

**Задача 2.1: Реализовать API эндпоинт для получения списка блюд**
**Цель:** Создать backend-метод, который возвращает данные для отображения меню с возможностью фильтрации по категориям.

**Функции:**
*   **Метод GET /dishes**
*   Поддержка параметра `category` для фильтрации по категориям.
*   Возвращает массив блюд с названием, изображением, описанием и ценой.

**Задача 2.2: Реализовать компонент карточки блюда**
**Цель:** Отображать информацию о блюде в соответствии с макетом.

**Требования:**
*   Компонент отображает: изображение (или заглушку, если изображения нет), название, описание, цену.
*   Реализовать логику подстановки стандартной картинки-заглушки, если `imageLink` отсутствует или равен `null`.

### **US-03: Добавление блюда в корзину**
*   **Как:** Посетитель
*   **Я хочу:** нажимать одну кнопку "Добавить" на карточке блюда в меню
*   **Чтобы:** быстро добавлять понравившиеся позиции в свой заказ.

**Задача 3.1: Реализовать API эндпоинты для работы с корзиной**
**Цель:** Создать backend-методы для управления корзиной.

**Необходимые методы:**
*   **Добавление/обновление товара в корзине: Метод POST /cart/items**
*   **Логика:** Если товар уже есть в корзине - обновляет количество, иначе добавляет новый.
*   **Получение количества товаров: Метод GET /cart/count**

**Задача 3.2: Реализовать кнопку добавления на карточке блюда**
**Цель:** Воспроизвести функциональность кнопки "Добавить" из макетов.

**Требования к реализации:**
*   Компонент принимает параметр `dishId`.
*   По клику вызывает API `POST /cart/items` с `quantity: 1`.
*   Реализовать визуальное подтверждение добавления (анимация или текст "Добавлено").
*   После успешного запроса обновляет счетчик в хедере, используя данные из ответа API или запрашивая `GET /cart/count`.

### **US-04: Просмотр и редактирование состава заказа**
*   **Как:** Посетитель
*   **Я хочу:** видеть список добавленных блюд, изменять их количество и удалять позиции
*   **Чтобы:** контролировать состав и сумму своего заказа перед оплатой.

**Задача 4.1: Реализовать API эндпоинт для данных корзины**
**Цель:** Создать backend-метод, который возвращает полные данные для отображения на экране "Проверка заказа".

**Функции:**
*   **Метод GET /cart/items**
*   Аутентификация по JWT-токену.
*   Возвращает актуальные данные корзины текущего пользователя: список позиций с названием, количеством, ценой за единицу и общей стоимостью позиции, а также общую сумму заказа.

**Задача 4.2: Реализовать API эндпоинт для изменения количества позиции**
**Цель:** Создать backend-метод для изменения количества товара в корзине.

**Функции:**
*   **Метод PUT /cart/items/{itemId}**
*   Принимает новое значение `quantity`.
*   Если `quantity` становится 0, позиция должна удаляться из корзины.

**Задача 4.3: Реализовать экран "Проверка заказа"**
**Цель:** Воспроизвести экран с списком товаров, возможностью редактирования и отображением суммы.

**Требования:**
*   При загрузке экрана данные запрашиваются через `GET /cart/items`.
*   Элементы управления "+" / "-" вызывают `PUT /cart/items/{itemId}`.
*   Кнопка "Удалить" устанавливает `quantity=0` для данной позиции.
*   Общая сумма заказа пересчитывается после каждого изменения.

### **US-05: Отображение суммы заказа**
*   **Как:** Посетитель
*   **Я хочу:** видеть общую сумму моего заказа в корзине и в шапке интерфейса
*   **Чтобы:** понимать итоговую стоимость перед переходом к оплате.

**Задача 5.1: Реализовать отображение суммы в корзине**
**Цель:** Отображать итоговую сумму к оплате на экране корзины.

**Требования:**
*   Данные о сумме берутся из ответа API `GET /cart/items` (поле `totalPrice`).
*   Сумма должна обновляться в реальном времени при изменении состава корзины.

**Задача 5.2: Реализовать индикатор суммы в шапке приложения**
**Цель:** Отображать общую сумму текущего заказа рядом с иконкой корзины.

**Требования:**
*   Реализовать компонент, который отображает сумму (например, "1 250 ₽").
*   Компонент должен отслеживать изменения в корзине и обновлять сумму (можно использовать данные из `GET /cart/items` или `GET /cart/count` с последующим уточнением).

### **US-06: Выбор способа оплаты** и **US-07: Безналичная оплата через терминал**
*   **Как:** Посетитель
*   **Я хочу:** выбирать между оплатой картой и наличными / безопасно оплатить заказ банковской картой
*   **Чтобы:** использовать удобный для меня способ расчета.

**Задача 6.1: Реализовать API для инициации оплаты**
**Цель:** Создать безопасное API для обработки платежей.

**Функции:**
*   **Метод POST /orders/{orderId}/payment**
*   Инициирует процесс оплаты для указанного заказа.
*   Возвращает ссылку для перенаправления на платежный шлюз (для онлайн-оплаты) или подтверждает выбор оплаты наличными.

**Задача 6.2: Реализовать экран выбора способа оплаты**
**Цель:** Создать интерфейс для выбора способа оплаты.

**Требования:**
*   Отображение доступных способов оплаты ("Банковская карта", "Наличными").
*   При выборе "Банковская карта" – вызов `POST /orders/{orderId}/payment` и перенаправление на шлюз.
*   При выборе "Наличными" – подтверждение заказа с соответствующим статусом.

**Задача 6.3: Реализовать вебхук для обработки статуса оплаты**
**Цель:** Обеспечить обработку уведомлений от платежной системы.

**Функции:**
*   **Метод POST /api/v1/payments/webhook (НУЖНО ДОБАВИТЬ)**
*   Скрытый URL, куда платежная система присылает статус оплаты.
*   На основе статуса меняет статус заказа в базе приложения.

### **US-08: Оплата наличными через менеджера по гостеприимству**
*   **Как:** Посетитель
*   **Я хочу:** иметь возможность оплатить наличными, если карта недоступна
*   **Чтобы:** не остаться без возможности сделать заказ.

**Задача 8.1: Реализовать логику оформления заказа с оплатой наличными**
**Цель:** Обеспечить оформление заказа без онлайн-оплаты.

**Требования:**
*   При выборе "Наличными" на экране оплаты, заказ оформляется с статусом `ожидает оплаты наличными`.
*   **Метод POST /cart/checkout** должен поддерживать `paymentMethod: "cash"`.
*   После подтверждения заказа отображается экран с информацией об ожидании и номере заказа.

### **US-09: Получение бумажного чека** и **US-10: Отображение номера заказа на экране**
*   **Как:** Посетитель
*   **Я хочу:** получить чек сразу после успешной оплаты / видеть номер моего заказа на экране
*   **Чтобы:** иметь подтверждение покупки.

**Задача 9.1: Реализовать API для получения деталей заказа после оплаты**
**Цель:** Создать метод для отображения финального экрана с номером заказа.

**Функции:**
*   **Метод GET /orders/{orderId}/status**
*   Дополнить ответ, чтобы он содержал номер заказа, итоговую сумму и статус.
*   **Новый метод для финального экрана: GET /orders/{orderId}/success (НУЖНО ДОБАВИТЬ)**
*   Возвращает данные для экрана "Заказ принят": номер заказа, статус "Готовится", итоговая сумма.

**Задача 9.2: Реализовать логику печати чека**
**Цель:** Интегрировать с системой печати.

**Требования:**
*   При успешном изменении статуса заказа на "Оплачен" (через вебхук `/payments/webhook`) система отправляет команду на печать на подключенный принтер.

### **US-11: Передача заказа на производство**
*   **Как:** Система
*   **Я хочу:** автоматически передавать оплаченный заказ в систему производства
*   **Чтобы:** кухня начала готовить сразу после оплаты.

**Задача 11.1: Реализовать механизм передачи заказа на кухню**
**Цель:** Обеспечить интеграцию с системой управления производством.

**Требования:**
*   Изменение статуса заказа на "Оплачен" (через вебхук) является триггером для передачи данных заказа в систему кухни (например, через внутреннее API или сообщение в брокер).
*   После подтверждения получения от системы кухни, статус заказа меняется на "Готовится".

### **US-12: Просмотр очереди заказов**
*   **Как:** Менеджер на производстве
*   **Я хочу:** видеть все текущие заказы с их статусами в реальном времени
*   **Чтобы:** контролировать загрузку кухни и контролировать процесс.

**Задача 12.1: Реализовать API эндпоинт для получения очереди заказов**
**Цель:** Создать backend-метод, который возвращает данные для отображения на панели мониторинга производства.

**Функции:**
- **Метод GET /api/v1/kitchen/orders**
- Аутентификация по JWT-токену с правами менеджера/администратора
- Поддержка фильтрации по статусу заказа (`queued`, `preparing`, `ready`)
- Возвращает заказы, отсортированные по времени создания и статусу

**Задача 12.2: Реализовать панель мониторинга производства**
**Цель:** Создать интерфейс для отображения очереди заказов на кухне.

**Требования:**
- Отображение заказов в виде карточек с номером заказа, составом и статусом
- Группировка заказов по статусам ("В очереди", "Готовятся", "Готовы")
- Автоматическое обновление данных каждые 30 секунд
- Визуальное выделение заказов с высоким приоритетом

**Задача 12.3: Реализовать WebSocket-подключение для реального времени**

**Цель:** Обеспечить мгновенное обновление данных на панели мониторинга.

**Требования:**
- Подключение к WebSocket endpoint `/api/v1/kitchen/updates`
- Обработка событий: `new_order`, `status_changed`, `order_completed`
- Автоматическое обновление интерфейса при получении событий

### **US-13: Автоматическое оповещение на табло**
*   **Как:** Система
*   **Я хочу:** автоматически отправлять номер готового заказа на табло в зоне выдачи
*   **Чтобы:** посетитель видел, когда его заказ готов.

**Задача 13.1: Реализовать API для управления табло готовности**

**Цель:** Создать методы для взаимодействия с табло в зоне выдачи.

**Необходимые методы:**
- **Метод POST /api/v1/kitchen/board/notify** - добавление заказа на табло
- **Метод DELETE /api/v1/kitchen/board/{orderId}** - удаление заказа с табло
- **Метод GET /api/v1/kitchen/board** - получение текущего состояния табло

**Задача 13.2: Реализовать автоматическую отправку на табло**

**Цель:** Настроить автоматическую отправку заказа на табло при смене статуса на "Готов".

**Требования к реализации:**
- Интеграция с методом изменения статуса заказа
- При статусе "ready" автоматически вызывается `POST /api/v1/kitchen/board/notify`
- Валидация успешной отправки на табло
- Логирование ошибок при проблемах с табло

**Задача 13.3: Реализовать механизм автоматического удаления с табло**

**Цель:** Обеспечить автоматическое удаление заказов с табло после выдачи или по истечении времени.

**Требования:**
- При статусе "completed" автоматически вызывается `DELETE /api/v1/kitchen/board/{orderId}`
- Фоновая задача для удаления заказов, находящихся на табло более 15 минут
- Уведомление менеджера о "зависших" заказах на табло

### **US-14: Визуальное отображение статуса готовности**
*   **Как:** Менеджер на производстве
*   **Я хочу:** видеть на панели мониторинга, какие заказы готовы к выдаче
*   **Чтобы:** контролировать процесс выдачи и избегать скопления готовых заказов.

**Задача 14.1: Реализовать визуальное выделение готовых заказов**

**Цель:** Обеспечить четкое визуальное различие между заказами с разными статусами.

**Требования к интерфейсу:**
- Заказы со статусом "Готов" выделяются зеленым цветом
- Отображение времени нахождения в статусе "Готов"
- Индикатор срочности для заказов
- Группировка заказов по статусу

**Задача 14.2: Реализовать сортировку и группировку заказов**

**Цель:** Обеспечить удобную организацию заказов на панели мониторинга.

**Требования к логике отображения:**
- Сортировка по статусу: сверху "Готов", затем "Готовится", затем "В очереди"
- Внутри группы сортировка по времени изменения статуса (сначала те, что дольше ожидают)
- Возможность ручной сортировки по приоритету или номеру заказа
- Фильтрация по времени принятия заказа

**Задача 14.3: Реализовать отображение времени готовности**

**Цель:** Показывать время нахождения заказа в каждом статусе.

**Требования:**
- Отображение времени в формате "Готов Х минут" для статуса "ready"
- Таймер реального времени, обновляющийся каждую минуту
- Цветовая индикация: до 2 минут - зеленый, 3-5 минут - желтый, более 5 минут - красный
- Уведомление менеджера при превышении лимита времени на выдачу
